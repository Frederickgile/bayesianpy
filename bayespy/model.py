# -*- coding: utf-8 -*-
"""
Created on Tue Apr 19 16:31:18 2016

@author: imorgan.admin
"""

from bayespy.jni import bayesServerInference
import bayespy.network
import pandas as pd
from bayespy.jni import bayesServer
from bayespy.jni import bayesServerParams
from bayespy.jni import jp
from bayespy.data import DataFrame

from collections import defaultdict

class QueryOutput:
    def __init__(self, continuous, discrete):
        self.continuous = continuous
        self.discrete = discrete

class InferenceEngine:

    inference_factory = bayesServerInference.RelevanceTreeInferenceFactory()

    def __init__(self, network):
        self._network = network

    def create(self, loglikelihood=False, conflict=False, retract=True):
        query_options = self.inference_factory.createQueryOptions()
        query_output = self.inference_factory.createQueryOutput()
        inference_engine = self.inference_factory.createInferenceEngine(self._network)

        query_options.setLogLikelihood(loglikelihood)
        query_options.setConflict(conflict)

        if retract:
            query_options.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)

        return inference_engine, query_options, query_output

class Query:

    _factory = bayesServerInference.RelevanceTreeInferenceFactory()
    def __init__(self, jnetwork, inference):
        self._queryOptions = self._factory.createQueryOptions();
        self._queryOutput = self._factory.createQueryOutput();
        self._queryDistributions = inference.getQueryDistributions()
        self._inference = inference
        self._jnetwork = jnetwork

    def execute(self, variables=None):
        """
        Query a number of variables (if none, then query all variables in the network)
        :param variables: a list of variables, or none
        :return: a QueryOutput object with separate continuous/ discrete dataframes
        """
        distributions = {}
        if variables is None:
            variables = self._jnetwork.getVariables()

        for v in variables:
            if bayespy.network.is_variable_discrete(v):
                table = bayesServer.Table(v)
            else:
                table = bayesServer.CLGaussian(v)

            self._queryDistributions.add(bayesServerInference.QueryDistribution(table))
            distributions.update({ v.getName() : table})

        self._inference.query(self._queryOptions, self._queryOutput)

        states= []
        d_variables = []
        values = []
        c_variables = []
        mean = []
        variance = []
        for v in variables:
            dist =  distributions[v.getName()]
            if bayespy.network.is_variable_discrete(v):
                for state in v.getStates():
                    states.append(state.getName())
                    values.append(float(dist.get([state])))
                    d_variables.append(v.getName())
            else:
                variance.append(float(dist.getVariance(v)))
                mean.append(float(dist.getMean(v)))
                c_variables.append(v.getName())

        return QueryOutput(pd.DataFrame({ 'variable': c_variables, 'mean': mean, 'variance': variance}), pd.DataFrame({ 'variable' : d_variables, 'state': states, 'value' : values}))

class Evidence:

    def __init__(self, jnetwork, inference):
        self._jnetwork = jnetwork
        self._inference = inference
        self._evidence = inference.getEvidence()
        self._evidence.clear()
        self._variables = jnetwork.getVariables()

    def apply(self, evidence):
        """
        Apply evidence to a network
        :param evidence: if a discrete variable, then a list of strings generated by network.Discrete.tostring(),
        if continuous, then a list of tuples with (VariableName, ContinuousValue)
        :return: Nothing
        """
        for value in evidence:
            if not isinstance(value, tuple):
                value = str(value)
                node, state = value.split(bayespy.network.STATE_DELIMITER)
                v = self._variables.get(node)
                if v is None:
                    raise ValueError("Node {} does not exist".format(node))
                if bayespy.network.is_variable_discrete(v):
                    st = v.getStates().get(state)
                    if st is None:
                        raise ValueError("State {} does not exist in variable {}".format(state, node))

                    self._evidence.setState(st)
                else:
                    raise ValueError("Can not find state on a continuous variable")
            else:
                v = self._variables.get(value[0])
                if not bayespy.network.is_variable_continuous(v):
                    raise ValueError("Variable is not continuous")

                self._evidence.set(v, jp.java.lang.Double(value[1]))

        return self._evidence

class NetworkModel:

    def __init__(self, network, data_store, logger):
        self._jnetwork = network
        self._factory = bayesServerInference.RelevanceTreeInferenceFactory()
        self._inference_factory = InferenceEngine(network)
        self._data_store = data_store
        self._logger = logger
        self._data = data_store.data

    def get_network(self):
        return self._jnetwork

    def _get_datareadercommand(self, indexes):
        """
        Get the data reader
        :param indexes: training/ testing indexes
        :return: a a DatabaseDataReaderCommand
        """
        data_reader_command = bayesServer.data.DatabaseDataReaderCommand(
                self._data_store.get_connection(),
                "select * from {} where ix in ({})".format(self._data_store.table, ",".join(str(i) for i in indexes)))

        return data_reader_command

    def _create_variablereferences(self, data):
        """
        Match up network variables to the dataframe columns
        :param data: dataframe
        :return: a list of 'VariableReference' objects
        """
        latent_variable_name = "Cluster"
        for v in self._jnetwork.getVariables():
            if v.getName().startswith(latent_variable_name):
                continue

            valueType = bayesServer.data.ColumnValueType.VALUE

            if v.getStateValueType() != bayesServer.StateValueType.DOUBLE_INTERVAL \
                    and bayespy.network.is_variable_discrete(v):

                if not DataFrame.is_int(data[v.getName()].dtype) and not DataFrame.is_bool(data[v.getName()].dtype):
                    valueType = bayesServer.data.ColumnValueType.NAME

            yield bayesServer.data.VariableReference(v, valueType, v.getName())

    def inference(self):
        return self._factory.createInferenceEngine(self._jnetwork);

    def create_query(self, inference):
        return Query(self._jnetwork, inference)

    def evidence(self, inference):
        return Evidence(self._jnetwork, inference)

    def save(self, path):
        from xml.dom import minidom
        nt = self._jnetwork.saveToString()
        reparsed = minidom.parseString(nt)
        with open(path, 'w') as fh:
            fh.write(reparsed.toprettyxml(indent="  "))


    def train(self, indexes=None):
        """
        Train a model on data provided in the constructor
        :param indexes: the 'training' indexes, if using KFold cross validation etc.
        :return:
        """
        learning = bayesServerParams.ParameterLearning(self._jnetwork, self._inference_factory.inference_factory)
        learning_options = bayesServerParams.ParameterLearningOptions()
        #learningOptions.setCalculateStatistics(True)

        if indexes is None:
            indexes = self._data.index.tolist()

        data_reader_command = self._get_datareadercommand(indexes)

        reader_options = bayesServer.data.ReaderOptions()

        variable_references = list(self._create_variablereferences(self._data))

        evidence_reader_command = bayesServer.data.DefaultEvidenceReaderCommand(data_reader_command,
                                            jp.java.util.Arrays.asList(variable_references), reader_options)

        self._logger.info("Training model...")
        result = learning.learn(evidence_reader_command, learning_options)
        self._logger.info("Finished training model")

        return {'Converged': result.getConverged(), 'Loglikelihood': result.getLogLikelihood().floatValue(),
                    'IterationCount': result.getIterationCount(), 'CaseCount': result.getCaseCount(),
                    'WeightedCaseCount': result.getWeightedCaseCount(), 'UnweightedCaseCount':  result.getUnweightedCaseCount(),
                    'BIC': result.getBIC().floatValue()}

    def batch_query(self, queries=[]):

        (inference_engine, query_options, query_output) = self._inference_factory.create(loglikelihood=True)

        data_reader_cmd = self._get_datareadercommand(self._data.index.tolist())

        data_reader = data_reader_cmd.executeReader()
        reader_options = bayesServer.data.ReaderOptions("ix")
        variable_refs = list(self._create_variablereferences(self._data))
        reader = bayesServer.data.DefaultEvidenceReader(data_reader, jp.java.util.Arrays.asList(variable_refs), reader_options)

        i = 0
        results = []
        while reader.read(inference_engine.getEvidence(), bayesServer.data.DefaultReadOptions(True)):
            try:
                #query_options.setLogLikelihood(True)
                inference_engine.query(query_options, query_output)
            except BaseException as e:
                print(e)

            loglikelihood = query_output.getLogLikelihood()
            caseId = reader.getReadInfo().getCaseId()
            #self._data.set_value(caseId, 'loglikelihood', loglikelihood)

            results.append({ 'caseid': caseId.value, 'loglikelihood': loglikelihood.value})

            if i % 500 == 0:
                self._logger.debug("Queried case {}".format(i))

            i += 1
            # for v, target in target_nodes:
            #     if bayespy.network.is_variable_continuous(v):
            #         #continuous
            #         results[v.getName()].append(target.getMean(v))
            #     else:
            #         # discrete
            #         states = {}
            #
            #         for state in v.getStates():
            #             states.update({ state.getName() : target.get([state])})
            #
            #         max_state = max(states.keys(), key=(lambda key: states[key]))
            #         if DataFrame.is_int(self._data[v.getName()].dtype):
            #             max_state = int(max_state)
            #
            #         states.update({'MaxStateLikelihood': max_state})
            #
            #         results[v.getName()].append(states)


            inference_engine.getEvidence().clear()

        reader.close()
        data_reader.close()

        df = pd.DataFrame(results)
        all_results = self._data.join(df.set_index('caseid'))

        return all_results

    # def predict(self, indexes, targets=[]):
    #     """
    #     Predict the output class given the trained model.
    #     :param indexes: Testing indexes (if using cross validation etc)
    #     :param targets: A list of target variables that are being queried
    #     :return: The list of target variables with probabilities/ states given the testing data
    #     """
    #     self._queryOptions.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)
    #     dataReaderCommand = self._get_datareadercommand(indexes)
    #
    #     target_nodes = []
    #     for target_node in targets:
    #         v = self._jnetwork.getVariables().get(target_node)
    #         if bayespy.network.is_variable_continuous(v):
    #             n = bayesServer.CLGaussian(v)
    #         else:
    #             n = bayesServer.Table(v)
    #
    #
    #         self._inference.getQueryDistributions().add(bayesServerInference.QueryDistribution(n));
    #         target_nodes.append((v, n))
    #
    #     dataReader = dataReaderCommand.executeReader()
    #     readerOptions = bayesServer.data.ReaderOptions()
    #     variableRefs = list(self._create_variablereferences(self._data))
    #     reader = bayesServer.data.DefaultEvidenceReader(dataReader, jp.java.util.Arrays.asList(variableRefs), readerOptions)
    #
    #     results = defaultdict(list)
    #     while reader.read(self._inference.getEvidence(), bayesServer.data.DefaultReadOptions(True)):
    #         try:
    #             self._inference.query(self._queryOptions, self._queryOutput)
    #         except BaseException as e:
    #             print(e)
    #
    #         for v, target in target_nodes:
    #             if bayespy.network.is_variable_continuous(v):
    #                 #continuous
    #                 results[v.getName()].append(target.getMean(v))
    #             else:
    #                 # discrete
    #                 states = {}
    #
    #                 for state in v.getStates():
    #                     states.update({ state.getName() : target.get([state])})
    #
    #                 max_state = max(states.keys(), key=(lambda key: states[key]))
    #                 if DataFrame.is_int(self._data[v.getName()].dtype):
    #                     max_state = int(max_state)
    #
    #                 states.update({'MaxStateLikelihood': max_state})
    #
    #                 results[v.getName()].append(states)
    #
    #
    #         self._inference.getEvidence().clear()
    #
    #     reader.close()
    #     dataReader.close()
    #     return {k:pd.DataFrame(v) for k,v in results.items()}




