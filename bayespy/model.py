# -*- coding: utf-8 -*-
"""
Created on Tue Apr 19 16:31:18 2016

@author: imorgan.admin
"""

from bayespy.jni import bayesServerInference
from bayespy.jni import bayesServerAnalysis
from bayespy.jni import bayesServerDiscovery

import bayespy.network
import pandas as pd
from bayespy.jni import bayesServer
from bayespy.jni import bayesServerParams
from bayespy.jni import jp
from bayespy.data import DataFrame
import numpy as np
from collections import defaultdict

class QueryOutput:
    def __init__(self, continuous, discrete):
        self.continuous = continuous
        self.discrete = discrete

class InferenceEngine:

    inference_factory = bayesServerInference.RelevanceTreeInferenceFactory()

    def __init__(self, network):
        self._network = network

    def create(self, loglikelihood=False, conflict=False, retract=False):
        query_options = self.inference_factory.createQueryOptions()
        query_output = self.inference_factory.createQueryOutput()
        inference_engine = self.inference_factory.createInferenceEngine(self._network)

        query_options.setLogLikelihood(loglikelihood)
        query_options.setConflict(conflict)

        if retract:
            query_options.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)

        return inference_engine, query_options, query_output

class Query:

    _factory = bayesServerInference.RelevanceTreeInferenceFactory()
    def __init__(self, jnetwork, inference):
        self._queryOptions = self._factory.createQueryOptions();
        self._queryOutput = self._factory.createQueryOutput();
        self._queryDistributions = inference.getQueryDistributions()
        self._inference = inference
        self._jnetwork = jnetwork

    def execute(self, variables=None):
        """
        Query a number of variables (if none, then query all variables in the network)
        :param variables: a list of variables, or none
        :return: a QueryOutput object with separate continuous/ discrete dataframes
        """
        distributions = {}
        if variables is None:
            variables = self._jnetwork.getVariables()

        for v in variables:
            if bayespy.network.is_variable_discrete(v):
                table = bayesServer.Table(v)
            else:
                table = bayesServer.CLGaussian(v)

            self._queryDistributions.add(bayesServerInference.QueryDistribution(table))
            distributions.update({ v.getName() : table})

        self._inference.query(self._queryOptions, self._queryOutput)

        states= []
        d_variables = []
        values = []
        c_variables = []
        mean = []
        variance = []
        for v in variables:
            dist =  distributions[v.getName()]
            if bayespy.network.is_variable_discrete(v):
                for state in v.getStates():
                    states.append(state.getName())
                    values.append(float(dist.get([state])))
                    d_variables.append(v.getName())
            else:
                variance.append(float(dist.getVariance(v)))
                mean.append(float(dist.getMean(v)))
                c_variables.append(v.getName())

        return QueryOutput(pd.DataFrame({ 'variable': c_variables, 'mean': mean, 'variance': variance}), pd.DataFrame({ 'variable' : d_variables, 'state': states, 'value' : values}))

class Evidence:

    def __init__(self, jnetwork, inference):
        self._jnetwork = jnetwork
        self._inference = inference
        self._evidence = inference.getEvidence()
        self._evidence.clear()
        self._variables = jnetwork.getVariables()

    def apply(self, evidence):
        """
        Apply evidence to a network
        :param evidence: if a discrete variable, then a list of strings generated by network.Discrete.tostring(),
        if continuous, then a list of tuples with (VariableName, ContinuousValue)
        :return: Nothing
        """
        for value in evidence:
            if not isinstance(value, tuple):
                value = str(value)
                node, state = value.split(bayespy.network.STATE_DELIMITER)
                v = self._variables.get(node)
                if v is None:
                    raise ValueError("Node {} does not exist".format(node))
                if bayespy.network.is_variable_discrete(v):
                    st = v.getStates().get(state)
                    if st is None:
                        raise ValueError("State {} does not exist in variable {}".format(state, node))

                    self._evidence.setState(st)
                else:
                    raise ValueError("Can not find state on a continuous variable")
            else:
                v = self._variables.get(value[0])
                if not bayespy.network.is_variable_continuous(v):
                    raise ValueError("Variable is not continuous")

                self._evidence.set(v, jp.java.lang.Double(value[1]))

        return self._evidence

class QueryStatistics:

    def __init__(self, calc_loglikelihood=True, calc_conflict=False, loglikelihood_column='loglikelihood', conflict_column='conflict'):
        self._calc_loglikelihood = calc_loglikelihood
        self._calc_conflict = calc_conflict
        self._loglikelihood_column = loglikelihood_column
        self._conflict_column = conflict_column

    def setup(self, inference_engine, query_options):
        query_options.setLogLikelihood(self._calc_loglikelihood)
        query_options.setConflict(self._calc_conflict)

    def results(self, inference_engine, query_output):
        result = {}
        if self._calc_loglikelihood:
            result.update({ self._loglikelihood_column: query_output.getLogLikelihood().floatValue() })

        if self._calc_conflict:
            result.update({ self._conflict_column: query_output.getConflict().floatValue()})

        return result

# seems like a better name than QueryStatistics, so just having this here.
class QueryModelStatistics(QueryStatistics):
    def __init__(self, calc_loglikelihood=True, calc_conflict=False, loglikelihood_column='loglikelihood', conflict_column='conflict'):
        super().__init__(calc_loglikelihood, calc_conflict, loglikelihood_column, conflict_column)

class QueryMostLikelyState:

    def __init__(self, network, target_variable_name, output_dtype="object", suffix="_maxlikelihood"):
        self._target_variable_name = target_variable_name
        self._distribution = None
        self._output_dtype = output_dtype
        self._variable = bayespy.network.get_variable(network, self._target_variable_name)
        self._suffix = suffix

    def setup(self, inference_engine, query_options):
        distribution = None
        if bayespy.network.is_variable_discrete(self._variable):
            distribution = bayesServer.Table(self._variable)

        if distribution is None:
            raise ValueError("{} needs to be discrete in QueryMostLikelyState".format(self._target_variable_name))

        query_options.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)
        qd = bayesServerInference.QueryDistribution(distribution)

        self._distribution = distribution
        inference_engine.getQueryDistributions().add(qd)

    def results(self, inference_engine, query_output):
        states = {}
        for state in self._variable.getStates():
            states.update({ state.getName() : self._distribution.get([state])})

        # get the most likely state
        max_state = max(states.keys(), key=(lambda key: states[key]))
        max_state_name = bayespy.data.DataFrame.cast2(self._output_dtype, max_state)

        return {self._target_variable_name + self._suffix: max_state_name}

class QueryLogLikelihood:
    def __init__(self, network, variable_names, column_name='_loglikelihood'):
        self._variable_names = variable_names
        self._distributions = []
        self._query_distributions = []
        for variable_name in variable_names:
            variable = bayespy.network.get_variable(network, variable_name)
            distribution = None
            if bayespy.network.is_variable_continuous(variable):
                distribution = bayesServer.CLGaussian(variable)
            elif bayespy.network.is_variable_discrete(variable):
                distribution = bayesServer.Table(variable)

            if distribution is not None:
                self._distributions.append(distribution)

        self._column_name = column_name

    def setup(self, inference_engine, query_options):
        query_options.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)
        for _, distribution in enumerate(self._distributions):
            qd = bayesServerInference.QueryDistribution(distribution)
            qd.setQueryLogLikelihood(True)
            self._query_distributions.append(qd)
            inference_engine.getQueryDistributions().add(qd)

    def results(self, inference_engine, query_output):
        result = {}
        for i, qd in enumerate(self._query_distributions):
            ll = qd.getLogLikelihood()
            if ll is not None:
                ll = ll.floatValue()
            result.update({self._variable_names[i] + self._column_name: ll})
        return result

class QueryMeanVariance:
    def __init__(self, network, variable_name, retract_evidence=True, result_mean_suffix='_mean', result_variance_suffix='_variance'):
        self._variable_name = variable_name
        self._variable = bayespy.network.get_variable(network, variable_name)

        if not bayespy.network.is_variable_continuous(self._variable):
            raise ValueError("{} needs to be continuous.".format(self._variable_name))

        self._query = bayesServer.CLGaussian(self._variable)
        self._result_mean_suffix = result_mean_suffix
        self._result_variance_suffix = result_variance_suffix
        self._retract_evidence = retract_evidence

    def setup(self, inference_engine, query_options):
        if self._retract_evidence:
            query_options.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)

        inference_engine.getQueryDistributions().add(bayesServerInference.QueryDistribution(self._query))

    def results(self, inference_engine, query_output):
        return {self._variable_name + self._result_mean_suffix: self._query.getMean(self._variable),
                self._variable_name + self._result_variance_suffix: self._query.getVariance(self._variable)}


class NetworkModel:

    def __init__(self, network, data_store, logger):
        self._jnetwork = network
        self._factory = bayesServerInference.RelevanceTreeInferenceFactory()
        self._inference_factory = InferenceEngine(network)
        self._data_store = data_store
        self._logger = logger
        self._data = data_store.data

    def get_network(self):
        return self._jnetwork

    def inference(self):
        return self._factory.createInferenceEngine(self._jnetwork)

    def create_query(self, inference):
        return Query(self._jnetwork, inference)

    def evidence(self, inference):
        return Evidence(self._jnetwork, inference)

    def save(self, path):
        from xml.dom import minidom
        nt = self._jnetwork.saveToString()
        reparsed = minidom.parseString(nt)
        with open(path, 'w') as fh:
            fh.write(reparsed.toprettyxml(indent="  "))

    def is_trained(self):
        return bayespy.network.is_trained(self._jnetwork)

    def train(self, indexes=None):
        """
        Train a model on data provided in the constructor
        :param indexes: the 'training' indexes, if using KFold cross validation etc.
        :return:
        """
        learning = bayesServerParams.ParameterLearning(self._jnetwork, self._inference_factory.inference_factory)
        learning_options = bayesServerParams.ParameterLearningOptions()

        if indexes is None:
            indexes = self._data.index.tolist()

        data_reader_command = self._data_store.create_data_reader_command()

        reader_options = bayesServer.data.ReaderOptions()

        variable_references = list(bayespy.network.create_variable_references(self._jnetwork, self._data))

        evidence_reader_command = bayesServer.data.DefaultEvidenceReaderCommand(data_reader_command,
                                            jp.java.util.Arrays.asList(variable_references), reader_options)

        self._logger.info("Training model...")
        result = learning.learn(evidence_reader_command, learning_options)
        self._logger.info("Finished training model")

        return {'Converged': result.getConverged(), 'Loglikelihood': result.getLogLikelihood().floatValue(),
                    'IterationCount': result.getIterationCount(), 'CaseCount': result.getCaseCount(),
                    'WeightedCaseCount': result.getWeightedCaseCount(), 'UnweightedCaseCount':  result.getUnweightedCaseCount(),
                    'BIC': result.getBIC().floatValue()}

    def _batch_query(self, reader, inference_engine, query_options, query_output, queries):
        i = 0
        results = []
        while reader.read(inference_engine.getEvidence(), bayesServer.data.DefaultReadOptions(True)):
            result = {}

            try:
                inference_engine.query(query_options, query_output)
            except BaseException as e:
                self._logger.error(e)
                #inference_engine.getEvidence().clear()
                #continue

            for query in queries:
                result = {**result, **query.results(inference_engine, query_output)}

            inference_engine.getEvidence().clear()
            result.update({'caseid': int(reader.getReadInfo().getCaseId().toString())})

            results.append(result)

            if i % 500 == 0:
                self._logger.info("Queried case {}".format(i))

            i += 1

        return results

    def batch_query(self, queries=[QueryStatistics()], append_to_df = True):

        (inference_engine, query_options, query_output) = self._inference_factory.create()

        data_reader_command = self._data_store.create_data_reader_command()
        data_reader = data_reader_command.executeReader()

        reader_options = bayesServer.data.ReaderOptions("ix")
        variable_refs = list(bayespy.network.create_variable_references(self._jnetwork, self._data))
        reader = bayesServer.data.DefaultEvidenceReader(data_reader, jp.java.util.Arrays.asList(variable_refs), reader_options)

        for query in queries:
            query.setup(inference_engine, query_options)

        try:
            results = self._batch_query(reader, inference_engine, query_options, query_output, queries)
        finally:
            reader.close()
            data_reader.close()

        df = pd.DataFrame(results).set_index('caseid')

        if append_to_df:
            return self._data.join(df)
        else:
            return df

    # def predict(self, indexes, targets=[]):
    #     """
    #     Predict the output class given the trained model.
    #     :param indexes: Testing indexes (if using cross validation etc)
    #     :param targets: A list of target variables that are being queried
    #     :return: The list of target variables with probabilities/ states given the testing data
    #     """
    #     self._queryOptions.setQueryEvidenceMode(bayesServerInference.QueryEvidenceMode.RETRACT_QUERY_EVIDENCE)
    #     dataReaderCommand = self._get_datareadercommand(indexes)
    #
    #     target_nodes = []
    #     for target_node in targets:
    #         v = self._jnetwork.getVariables().get(target_node)
    #         if bayespy.network.is_variable_continuous(v):
    #             n = bayesServer.CLGaussian(v)
    #         else:
    #             n = bayesServer.Table(v)
    #
    #
    #         self._inference.getQueryDistributions().add(bayesServerInference.QueryDistribution(n));
    #         target_nodes.append((v, n))
    #
    #     dataReader = dataReaderCommand.executeReader()
    #     readerOptions = bayesServer.data.ReaderOptions()
    #     variableRefs = list(self._create_variablereferences(self._data))
    #     reader = bayesServer.data.DefaultEvidenceReader(dataReader, jp.java.util.Arrays.asList(variableRefs), readerOptions)
    #
    #     results = defaultdict(list)
    #     while reader.read(self._inference.getEvidence(), bayesServer.data.DefaultReadOptions(True)):
    #         try:
    #             self._inference.query(self._queryOptions, self._queryOutput)
    #         except BaseException as e:
    #             print(e)
    #
    #         for v, target in target_nodes:
    #             if bayespy.network.is_variable_continuous(v):
    #                 #continuous
    #                 results[v.getName()].append(target.getMean(v))
    #             else:
    #                 # discrete
    #                 states = {}
    #
    #                 for state in v.getStates():
    #                     states.update({ state.getName() : target.get([state])})
    #
    #                 max_state = max(states.keys(), key=(lambda key: states[key]))
    #                 if DataFrame.is_int(self._data[v.getName()].dtype):
    #                     max_state = int(max_state)
    #
    #                 states.update({'MaxStateLikelihood': max_state})
    #
    #                 results[v.getName()].append(states)
    #
    #
    #         self._inference.getEvidence().clear()
    #
    #     reader.close()
    #     dataReader.close()
    #     return {k:pd.DataFrame(v) for k,v in results.items()}








